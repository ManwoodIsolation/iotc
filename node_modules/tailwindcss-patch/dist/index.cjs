'use strict';

const fs$1 = require('node:fs/promises');
const path = require('node:path');
const fs = require('node:fs');
const pkg = require('resolve');
const semver = require('semver');
const t = require('@babel/types');
const _babelGenerate = require('@babel/generator');
const _babelTraverse = require('@babel/traverse');
const parser = require('@babel/parser');
const postcss = require('postcss');
const lilconfig = require('lilconfig');
const createJiti = require('jiti');
const config = require('@tailwindcss-mangle/config');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  const n = Object.create(null);
  if (e) {
    for (const k in e) {
      n[k] = e[k];
    }
  }
  n.default = e;
  return n;
}

const fs__default$1 = /*#__PURE__*/_interopDefaultCompat(fs$1);
const path__default = /*#__PURE__*/_interopDefaultCompat(path);
const fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
const pkg__default = /*#__PURE__*/_interopDefaultCompat(pkg);
const t__namespace = /*#__PURE__*/_interopNamespaceCompat(t);
const _babelGenerate__default = /*#__PURE__*/_interopDefaultCompat(_babelGenerate);
const _babelTraverse__default = /*#__PURE__*/_interopDefaultCompat(_babelTraverse);
const postcss__default = /*#__PURE__*/_interopDefaultCompat(postcss);
const createJiti__default = /*#__PURE__*/_interopDefaultCompat(createJiti);

const { sync } = pkg__default;
function ensureFileContent(filepaths) {
  if (typeof filepaths === "string") {
    filepaths = [filepaths];
  }
  let content;
  for (const filepath of filepaths) {
    if (fs__default.existsSync(filepath)) {
      content = fs__default.readFileSync(filepath, {
        encoding: "utf8"
      });
      break;
    }
  }
  return content;
}
function requireResolve(id, opts) {
  return sync(id, opts);
}
async function ensureDir(p) {
  try {
    await fs__default$1.access(p);
  } catch {
    await fs__default$1.mkdir(p, {
      recursive: true
    });
  }
}

function getTailwindcssEntry(basedir) {
  return requireResolve("tailwindcss", {
    basedir
  });
}
function getContexts(basedir) {
  const twPath = getTailwindcssEntry(basedir);
  const distPath = path__default.dirname(twPath);
  let injectFilePath = path__default.join(distPath, "plugin.js");
  if (!fs__default.existsSync(injectFilePath)) {
    injectFilePath = path__default.join(distPath, "index.js");
  }
  const mo = require(injectFilePath);
  if (mo.contextRef) {
    return mo.contextRef.value;
  }
  return [];
}
function getClassCaches(basedir) {
  const contexts = getContexts(basedir);
  return contexts.map((x) => x.classCache);
}
function getClassCacheSet(basedir, options) {
  const classCaches = getClassCaches(basedir);
  const classSet = /* @__PURE__ */ new Set();
  for (const classCacheMap of classCaches) {
    const keys = classCacheMap.keys();
    for (const key of keys) {
      const v = key.toString();
      if (options?.removeUniversalSelector && v === "*") {
        continue;
      }
      classSet.add(v);
    }
  }
  return classSet;
}

const pkgName = "tailwindcss-patch";

function log(message, ...optionalParams) {
  return console.log(`[${pkgName}]:` + message, ...optionalParams);
}

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function getCacheOptions(options) {
  let cache;
  switch (typeof options) {
    case "undefined": {
      cache = {
        enable: false
      };
      break;
    }
    case "boolean": {
      cache = {
        enable: options
      };
      break;
    }
    case "object": {
      cache = { ...options, enable: true };
      break;
    }
  }
  return cache;
}
class CacheManager {
  constructor(options = {}) {
    __publicField$1(this, "options");
    this.options = this.getOptions(options);
  }
  mkdir(cacheDirectory) {
    const exists = fs__default.existsSync(cacheDirectory);
    if (!exists) {
      fs__default.mkdirSync(cacheDirectory, {
        recursive: true
      });
    }
    return cacheDirectory;
  }
  getOptions(options = {}) {
    const cwd = options.cwd ?? process.cwd();
    const dir = options.dir ?? path__default.resolve(cwd, "node_modules/.cache", pkgName);
    const file = options.file ?? "index.json";
    const filename = path__default.resolve(dir, file);
    return {
      cwd,
      dir,
      file,
      filename,
      strategy: "merge"
    };
  }
  write(data) {
    try {
      const { dir, filename } = this.options;
      this.mkdir(dir);
      fs__default.writeFileSync(filename, JSON.stringify([...data], void 0, 2), "utf8");
      return filename;
    } catch {
      log("write cache file fail!");
    }
  }
  read() {
    const { filename } = this.options;
    try {
      if (fs__default.existsSync(filename)) {
        const data = fs__default.readFileSync(filename, "utf8");
        return new Set(JSON.parse(data));
      }
    } catch {
      log("parse cache content fail! path:" + filename);
      try {
        fs__default.unlinkSync(filename);
      } catch {
        log("delete cache file fail! path:" + filename);
      }
    }
  }
}

function isPlainObject(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {
    return false;
  }
  if (Symbol.iterator in value) {
    return false;
  }
  if (Symbol.toStringTag in value) {
    return Object.prototype.toString.call(value) === "[object Module]";
  }
  return true;
}

function _defu(baseObject, defaults, namespace = ".", merger) {
  if (!isPlainObject(defaults)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (merger && merger(object, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isPlainObject(value) && isPlainObject(object[key])) {
      object[key] = _defu(
        value,
        object[key],
        (namespace ? `${namespace}.` : "") + key.toString(),
        merger
      );
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p, c) => _defu(p, c, "", merger), {})
  );
}
const defu = createDefu();

function _interopDefaultCompat$1(e) {
  return e && typeof e === "object" && "default" in e ? e.default : e;
}
const generate = _interopDefaultCompat$1(_babelGenerate__default);
const traverse = _interopDefaultCompat$1(_babelTraverse__default);

function inspectProcessTailwindFeaturesReturnContext(content) {
  const ast = parser.parse(content);
  let hasPatched = false;
  traverse(ast, {
    FunctionDeclaration(p) {
      const n = p.node;
      if (n.id?.name === "processTailwindFeatures" && n.body.body.length === 1 && t__namespace.isReturnStatement(n.body.body[0])) {
        const rts = n.body.body[0];
        if (t__namespace.isFunctionExpression(rts.argument)) {
          const body = rts.argument.body.body;
          const lastStatement = body[body.length - 1];
          hasPatched = t__namespace.isReturnStatement(lastStatement) && t__namespace.isIdentifier(lastStatement.argument) && lastStatement.argument.name === "context";
          if (!hasPatched) {
            const rts2 = t__namespace.returnStatement(t__namespace.identifier("context"));
            body.push(rts2);
          }
        }
      }
    }
  });
  return {
    code: hasPatched ? content : generate(ast).code,
    hasPatched
  };
}
function inspectPostcssPlugin(content) {
  const ast = parser.parse(content);
  const exportKey = "contextRef";
  const variableName = "contextRef";
  const valueKey = "value";
  let hasPatched = false;
  traverse(ast, {
    Program(p) {
      const n = p.node;
      const idx = n.body.findIndex((x) => {
        return t__namespace.isExpressionStatement(x) && t__namespace.isAssignmentExpression(x.expression) && t__namespace.isMemberExpression(x.expression.left) && t__namespace.isFunctionExpression(x.expression.right) && x.expression.right.id?.name === "tailwindcss";
      });
      if (idx > -1) {
        const prevStatement = n.body[idx - 1];
        const lastStatement = n.body[n.body.length - 1];
        const hasPatchedCondition0 = prevStatement && t__namespace.isVariableDeclaration(prevStatement) && prevStatement.declarations.length === 1 && t__namespace.isIdentifier(prevStatement.declarations[0].id) && prevStatement.declarations[0].id.name === variableName;
        const hasPatchedCondition1 = t__namespace.isExpressionStatement(lastStatement) && t__namespace.isAssignmentExpression(lastStatement.expression) && t__namespace.isIdentifier(lastStatement.expression.right) && lastStatement.expression.right.name === variableName;
        hasPatched = hasPatchedCondition0 || hasPatchedCondition1;
        if (!hasPatched) {
          const statement = t__namespace.variableDeclaration("const", [
            t__namespace.variableDeclarator(t__namespace.identifier(variableName), t__namespace.objectExpression([t__namespace.objectProperty(t__namespace.identifier(valueKey), t__namespace.arrayExpression())]))
          ]);
          n.body.splice(idx, 0, statement);
          n.body.push(
            t__namespace.expressionStatement(
              t__namespace.assignmentExpression(
                "=",
                t__namespace.memberExpression(t__namespace.memberExpression(t__namespace.identifier("module"), t__namespace.identifier("exports")), t__namespace.identifier(exportKey)),
                t__namespace.identifier(variableName)
              )
            )
          );
        }
      }
    },
    FunctionExpression(p) {
      if (hasPatched) {
        return;
      }
      const n = p.node;
      if (n.id?.name === "tailwindcss" && n.body.body.length === 1 && t__namespace.isReturnStatement(n.body.body[0])) {
        const returnStatement = n.body.body[0];
        if (t__namespace.isObjectExpression(returnStatement.argument) && returnStatement.argument.properties.length === 2) {
          const properties = returnStatement.argument.properties;
          if (t__namespace.isObjectProperty(properties[0]) && t__namespace.isObjectProperty(properties[1])) {
            const keyMatched = t__namespace.isIdentifier(properties[0].key) && properties[0].key.name === "postcssPlugin";
            const pluginsMatched = t__namespace.isIdentifier(properties[1].key) && properties[1].key.name === "plugins";
            if (pluginsMatched && keyMatched && t__namespace.isCallExpression(properties[1].value) && t__namespace.isMemberExpression(properties[1].value.callee) && t__namespace.isArrayExpression(properties[1].value.callee.object)) {
              const pluginsCode = properties[1].value.callee.object.elements;
              if (pluginsCode[1] && t__namespace.isFunctionExpression(pluginsCode[1])) {
                const targetBlockStatement = pluginsCode[1].body;
                const lastStatement = targetBlockStatement.body[targetBlockStatement.body.length - 1];
                if (t__namespace.isExpressionStatement(lastStatement)) {
                  const newExpressionStatement = t__namespace.expressionStatement(
                    t__namespace.callExpression(
                      t__namespace.memberExpression(
                        t__namespace.memberExpression(t__namespace.identifier(variableName), t__namespace.identifier("value")),
                        t__namespace.identifier("push")
                      ),
                      [lastStatement.expression]
                    )
                  );
                  targetBlockStatement.body[targetBlockStatement.body.length - 1] = newExpressionStatement;
                }
                const ifIdx = targetBlockStatement.body.findIndex((x) => t__namespace.isIfStatement(x));
                if (ifIdx > -1) {
                  const ifRoot = targetBlockStatement.body[ifIdx];
                  if (t__namespace.isBlockStatement(ifRoot.consequent) && ifRoot.consequent.body[1] && t__namespace.isForOfStatement(ifRoot.consequent.body[1])) {
                    const forOf = ifRoot.consequent.body[1];
                    if (t__namespace.isBlockStatement(forOf.body) && forOf.body.body.length === 1 && t__namespace.isIfStatement(forOf.body.body[0])) {
                      const if2 = forOf.body.body[0];
                      if (t__namespace.isBlockStatement(if2.consequent) && if2.consequent.body.length === 1 && t__namespace.isExpressionStatement(if2.consequent.body[0])) {
                        const target = if2.consequent.body[0];
                        const newExpressionStatement = t__namespace.expressionStatement(
                          t__namespace.callExpression(t__namespace.memberExpression(t__namespace.memberExpression(t__namespace.identifier(variableName), t__namespace.identifier("value")), t__namespace.identifier("push")), [target.expression])
                        );
                        if2.consequent.body[0] = newExpressionStatement;
                      }
                    }
                  }
                }
                targetBlockStatement.body.unshift(
                  // contentRef.value = []
                  // t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.identifier(variableName), t.identifier(valueKey)), t.arrayExpression()))
                  // contentRef.value.length = 0
                  t__namespace.expressionStatement(
                    t__namespace.assignmentExpression(
                      "=",
                      t__namespace.memberExpression(t__namespace.memberExpression(t__namespace.identifier(variableName), t__namespace.identifier(valueKey)), t__namespace.identifier("length")),
                      t__namespace.numericLiteral(0)
                    )
                  )
                );
              }
            }
          }
        }
      }
    }
    // BlockStatement(p) {
    //   const n = p.node
    //   if (start && p.parent.type === 'FunctionExpression' && !p.parent.id) {
    //     n.body.unshift(t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.identifier(variableName), t.identifier(valueKey)), t.arrayExpression())))
    //   }
    // }
  });
  return {
    code: hasPatched ? content : generate(ast).code,
    hasPatched
  };
}

function getDefaultPatchOptions() {
  return {
    overwrite: true
  };
}

function getInstalledPkgJsonPath(options = {}) {
  try {
    const tmpJsonPath = requireResolve(`tailwindcss/package.json`, {
      paths: options.paths
    });
    return tmpJsonPath;
  } catch (error) {
    if (error.code === "MODULE_NOT_FOUND") {
      console.warn("Can't find npm pkg: `tailwindcss`, Please ensure it has been installed!");
    }
  }
}
function getPatchOptions(options = {}) {
  return defu(
    options,
    {
      basedir: process.cwd()
    },
    getDefaultPatchOptions()
  );
}
function createPatch(opt) {
  return () => {
    try {
      const pkgJsonPath = getInstalledPkgJsonPath(opt);
      return internalPatch(pkgJsonPath, opt);
    } catch (error) {
      console.warn(`patch tailwindcss failed:` + error.message);
    }
  };
}
function monkeyPatchForExposingContext(twDir, opt) {
  const processTailwindFeaturesFilePath = path__default.resolve(twDir, "lib/processTailwindFeatures.js");
  const processTailwindFeaturesContent = ensureFileContent(processTailwindFeaturesFilePath);
  const result = {};
  if (processTailwindFeaturesContent) {
    const { code, hasPatched } = inspectProcessTailwindFeaturesReturnContext(processTailwindFeaturesContent);
    if (!hasPatched && opt.overwrite) {
      fs__default.writeFileSync(processTailwindFeaturesFilePath, code, {
        encoding: "utf8"
      });
      console.log("patch tailwindcss processTailwindFeatures for return content successfully!");
    }
    result.processTailwindFeatures = code;
  }
  const pluginFilePath = path__default.resolve(twDir, "lib/plugin.js");
  const indexFilePath = path__default.resolve(twDir, "lib/index.js");
  const pluginContent = ensureFileContent([pluginFilePath, indexFilePath]);
  if (pluginContent) {
    const { code, hasPatched } = inspectPostcssPlugin(pluginContent);
    if (!hasPatched && opt.overwrite) {
      fs__default.writeFileSync(pluginFilePath, code, {
        encoding: "utf8"
      });
      console.log("patch tailwindcss for expose runtime content successfully!");
    }
    result.plugin = code;
  }
  opt.custom && typeof opt.custom === "function" && opt.custom(twDir, result);
  return result;
}
function internalPatch(pkgJsonPath, options) {
  if (pkgJsonPath) {
    const pkgJson = require(pkgJsonPath);
    const twDir = path__default.dirname(pkgJsonPath);
    if (semver.gte(pkgJson.version, "3.0.0")) {
      options.version = pkgJson.version;
      const result = monkeyPatchForExposingContext(twDir, options);
      return result;
    }
  }
}

const jiti = createJiti__default(__filename);
async function processTailwindcss(options) {
  options.cwd = options.cwd ?? process.cwd();
  let config = options.config;
  if (!(typeof options.config === "string" && path__default.isAbsolute(options.config))) {
    const moduleName = "tailwind";
    const result = await lilconfig.lilconfig("tailwindcss", {
      searchPlaces: [
        `${moduleName}.config.js`,
        `${moduleName}.config.cjs`,
        `${moduleName}.config.mjs`,
        `${moduleName}.config.ts`,
        `${moduleName}.config.cts`,
        `${moduleName}.config.mts`
      ],
      loaders: {
        // 默认支持 js 和 cjs 2种格式
        ".js": jiti,
        ".cjs": jiti,
        ".mjs": jiti,
        ".ts": jiti,
        ".cts": jiti,
        ".mts": jiti
      }
    }).search(options.cwd);
    if (!result) {
      throw new Error(`No TailwindCSS Config found in: ${options.cwd}`);
    }
    config = result.filepath;
  }
  return await postcss__default([
    require("tailwindcss")({
      config
    })
  ]).process("@tailwind base;@tailwind components;@tailwind utilities;", {
    from: void 0
  });
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class TailwindcssPatcher {
  constructor(options = {}) {
    __publicField(this, "rawOptions");
    __publicField(this, "cacheOptions");
    __publicField(this, "patchOptions");
    __publicField(this, "patch");
    __publicField(this, "cacheManager");
    this.rawOptions = options;
    this.cacheOptions = getCacheOptions(options.cache);
    this.patchOptions = getPatchOptions(options.patch);
    this.patch = createPatch(this.patchOptions);
    this.cacheManager = new CacheManager(this.cacheOptions);
  }
  getPkgEntry(basedir) {
    return getTailwindcssEntry(basedir);
  }
  setCache(set) {
    if (this.cacheOptions.enable) {
      return this.cacheManager.write(set);
    }
  }
  getCache() {
    return this.cacheManager.read();
  }
  /**
   * @description 在多个 tailwindcss 上下文时，这个方法将被执行多次，所以策略上应该使用 append
   * 详见 taro weapp-tailwindcss 独立分包
   * @param basedir
   * @returns
   */
  getClassSet(options) {
    const { basedir, cacheStrategy = this.cacheOptions.strategy ?? "merge", removeUniversalSelector = true } = options ?? {};
    const set = getClassCacheSet(basedir, {
      removeUniversalSelector
    });
    if (cacheStrategy === "overwrite") {
      set.size > 0 && this.setCache(set);
    } else if (cacheStrategy === "merge") {
      const cacheSet = this.getCache();
      if (cacheSet) {
        for (const x of cacheSet) {
          set.add(x);
        }
      }
      this.setCache(set);
    }
    return set;
  }
  getContexts(basedir) {
    return getContexts(basedir);
  }
  async extract(options) {
    const { output, tailwindcss } = options ?? {};
    if (output && tailwindcss) {
      const { removeUniversalSelector, filename, loose } = output;
      await processTailwindcss(tailwindcss);
      const set = this.getClassSet({
        removeUniversalSelector
      });
      if (filename) {
        await ensureDir(path.dirname(filename));
        const classList = [...set];
        await fs__default$1.writeFile(filename, JSON.stringify(classList, null, loose ? 2 : void 0), "utf8");
        return filename;
      }
    }
  }
}

exports.defineConfig = config.defineConfig;
exports.CacheManager = CacheManager;
exports.TailwindcssPatcher = TailwindcssPatcher;
exports.createPatch = createPatch;
exports.ensureDir = ensureDir;
exports.ensureFileContent = ensureFileContent;
exports.getCacheOptions = getCacheOptions;
exports.getClassCacheSet = getClassCacheSet;
exports.getClassCaches = getClassCaches;
exports.getContexts = getContexts;
exports.getInstalledPkgJsonPath = getInstalledPkgJsonPath;
exports.getPatchOptions = getPatchOptions;
exports.getTailwindcssEntry = getTailwindcssEntry;
exports.inspectPostcssPlugin = inspectPostcssPlugin;
exports.inspectProcessTailwindFeaturesReturnContext = inspectProcessTailwindFeaturesReturnContext;
exports.internalPatch = internalPatch;
exports.monkeyPatchForExposingContext = monkeyPatchForExposingContext;
exports.requireResolve = requireResolve;
