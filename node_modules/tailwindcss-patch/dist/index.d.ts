import { Rule, Node } from 'postcss';
import { Config } from 'tailwindcss';
import { UserConfig } from '@tailwindcss-mangle/config';
export { defineConfig } from '@tailwindcss-mangle/config';
import { SyncOpts } from 'resolve';

type CacheStrategy = 'merge' | 'overwrite';
interface CacheOptions {
    dir?: string;
    cwd?: string;
    file?: string;
    strategy?: CacheStrategy;
}
type InternalCacheOptions = CacheOptions & {
    enable?: boolean;
};
interface PatchOptions {
    overwrite?: boolean;
    paths?: string[];
    basedir?: string;
    custom?: (dir: string, ctx: Record<string, any>) => void;
}
interface InternalPatchOptions {
    overwrite: boolean;
    paths?: string[];
    basedir?: string;
    custom?: (dir: string, ctx: Record<string, any>) => void;
    version?: string;
}
interface TailwindcssPatcherOptions {
    cache?: CacheOptions | boolean;
    patch?: PatchOptions;
}
type TailwindcssClassCache = Map<string, ({
    layer: string;
    options: Record<string, any>;
    sort: Record<string, any>;
} | Rule)[]>;
type TailwindcssRuntimeContext = {
    applyClassCache: Map<any, any>;
    candidateRuleCache: Map<string | string, Set<[
        {
            arbitrary: any;
            index: any;
            layer: string;
            options: any[];
            parallelIndex: any;
            parentLayer: string;
            variants: any;
        },
        Node
    ]>>;
    candidateRuleMap: Map<string | string, [object, Node][]>;
    changedContent: any[];
    classCache: TailwindcssClassCache;
    disposables: any[];
    getClassList: Function;
    getClassOrder: Function;
    getVariants: Function;
    markInvalidUtilityCandidate: Function;
    markInvalidUtilityNode: Function;
    notClassCache: Set<string>;
    offsets: {
        layerPositions: object;
        offsets: object;
        reservedVariantBits: any;
        variantOffsets: Map<string, any>;
    };
    postCssNodeCache: Map<object, [Node]>;
    ruleCache: Set<[object, Node]>;
    stylesheetCache: Record<string, Set<any>>;
    tailwindConfig: Config;
    userConfigPath: string | null;
    variantMap: Map<string, [[object, Function]]>;
    variantOptions: Map<string, object>;
};
type DeepRequired<T> = {
    [K in keyof T]: Required<DeepRequired<T[K]>>;
};

declare function getCacheOptions(options?: CacheOptions | boolean): InternalCacheOptions;
declare class CacheManager {
    options: Required<CacheOptions> & {
        filename: string;
    };
    constructor(options?: CacheOptions);
    mkdir(cacheDirectory: string): string;
    getOptions(options?: CacheOptions): Required<CacheOptions> & {
        filename: string;
    };
    write(data: Set<string>): string | undefined;
    read(): Set<string> | undefined;
}

declare class TailwindcssPatcher {
    rawOptions: TailwindcssPatcherOptions;
    cacheOptions: InternalCacheOptions;
    patchOptions: InternalPatchOptions;
    patch: () => void;
    cacheManager: CacheManager;
    constructor(options?: TailwindcssPatcherOptions);
    getPkgEntry(basedir?: string): string;
    setCache(set: Set<string>): string | undefined;
    getCache(): Set<string> | undefined;
    /**
     * @description 在多个 tailwindcss 上下文时，这个方法将被执行多次，所以策略上应该使用 append
     * 详见 taro weapp-tailwindcss 独立分包
     * @param basedir
     * @returns
     */
    getClassSet(options?: {
        basedir?: string;
        cacheStrategy?: CacheStrategy;
        removeUniversalSelector?: boolean;
    }): Set<string>;
    getContexts(basedir?: string): TailwindcssRuntimeContext[];
    extract(options?: UserConfig['patch']): Promise<string | undefined>;
}

declare function getTailwindcssEntry(basedir?: string): string;
declare function getContexts(basedir?: string): TailwindcssRuntimeContext[];
declare function getClassCaches(basedir?: string): TailwindcssClassCache[];
declare function getClassCacheSet(basedir?: string, options?: {
    removeUniversalSelector?: boolean;
}): Set<string>;

declare function inspectProcessTailwindFeaturesReturnContext(content: string): {
    code: string;
    hasPatched: boolean;
};
declare function inspectPostcssPlugin(content: string): {
    code: string;
    hasPatched: boolean;
};

declare function getInstalledPkgJsonPath(options?: PatchOptions): string | undefined;
declare function getPatchOptions(options?: PatchOptions): InternalPatchOptions;
declare function createPatch(opt: InternalPatchOptions): () => any;
declare function monkeyPatchForExposingContext(twDir: string, opt: InternalPatchOptions): {
    processTailwindFeatures?: string | undefined;
    plugin?: string | undefined;
} & Record<string, any>;
declare function internalPatch(pkgJsonPath: string | undefined, options: InternalPatchOptions): any | undefined;

declare function ensureFileContent(filepaths: string | string[]): string | undefined;
declare function requireResolve(id: string, opts?: SyncOpts): string;
declare function ensureDir(p: string): Promise<void>;

export { CacheManager, type CacheOptions, type CacheStrategy, type DeepRequired, type InternalCacheOptions, type InternalPatchOptions, type PatchOptions, type TailwindcssClassCache, TailwindcssPatcher, type TailwindcssPatcherOptions, type TailwindcssRuntimeContext, createPatch, ensureDir, ensureFileContent, getCacheOptions, getClassCacheSet, getClassCaches, getContexts, getInstalledPkgJsonPath, getPatchOptions, getTailwindcssEntry, inspectPostcssPlugin, inspectProcessTailwindFeaturesReturnContext, internalPatch, monkeyPatchForExposingContext, requireResolve };
