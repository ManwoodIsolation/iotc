'use strict';

var options = require('./options-BAFFNEBI.js');
var plugin = require('./plugin-Bxt3oO75.js');
var defaults = require('./defaults-qX2VLo8u.js');
var index = require('./index-CKXO21Qe.js');

const debug = index.createDebug('generateBundle: ');
function UnifiedViteWeappTailwindcssPlugin(options$1 = {}) {
    if (options$1.customReplaceDictionary === undefined) {
        options$1.customReplaceDictionary = 'simple';
    }
    const opts = options.getOptions(options$1);
    const { disabled, onEnd, onLoad, onStart, onUpdate, templateHandler, styleHandler, patch, jsHandler, mainCssChunkMatcher, appType, setMangleRuntimeSet, cache, tailwindcssBasedir } = opts;
    if (disabled) {
        return;
    }
    patch === null || patch === void 0 ? void 0 : patch();
    const twPatcher = options.createTailwindcssPatcher();
    onLoad();
    return {
        name: plugin.vitePluginName,
        enforce: 'post',
        generateBundle(opt, bundle) {
            return options.__awaiter(this, void 0, void 0, function* () {
                debug('start');
                onStart();
                const entries = Object.entries(bundle);
                const groupedEntries = defaults.getGroupedEntries(entries, opts);
                const runtimeSet = twPatcher.getClassSet({
                    basedir: tailwindcssBasedir
                });
                setMangleRuntimeSet(runtimeSet);
                debug('get runtimeSet, class count: %d', runtimeSet.size);
                if (Array.isArray(groupedEntries.html)) {
                    let noCachedCount = 0;
                    for (let i = 0; i < groupedEntries.html.length; i++) {
                        const [file, originalSource] = groupedEntries.html[i];
                        const oldVal = originalSource.source.toString();
                        const hash = cache.computeHash(oldVal);
                        cache.calcHashValueChanged(file, hash);
                        yield cache.process(file, () => {
                            const source = cache.get(file);
                            if (source) {
                                originalSource.source = source;
                                debug('html cache hit: %s', file);
                            }
                            else {
                                return false;
                            }
                        }, () => {
                            originalSource.source = templateHandler(oldVal, {
                                runtimeSet
                            });
                            onUpdate(file, oldVal, originalSource.source);
                            debug('html handle: %s', file);
                            noCachedCount++;
                            return {
                                key: file,
                                source: originalSource.source
                            };
                        });
                    }
                    debug('html handle finish, total: %d, no-cached: %d', groupedEntries.html.length, noCachedCount);
                }
                if (Array.isArray(groupedEntries.js)) {
                    let noCachedCount = 0;
                    for (let i = 0; i < groupedEntries.js.length; i++) {
                        const [file, originalSource] = groupedEntries.js[i];
                        const rawSource = originalSource.code;
                        const hash = cache.computeHash(rawSource);
                        cache.calcHashValueChanged(file, hash);
                        yield cache.process(file, () => {
                            const source = cache.get(file);
                            if (source) {
                                originalSource.code = source;
                                debug('js cache hit: %s', file);
                            }
                            else {
                                return false;
                            }
                        }, () => {
                            const mapFilename = file + '.map';
                            const hasMap = Boolean(bundle[mapFilename]);
                            const { code, map } = jsHandler(rawSource, runtimeSet, {
                                generateMap: hasMap
                            });
                            originalSource.code = code;
                            onUpdate(file, rawSource, code);
                            debug('js handle: %s', file);
                            noCachedCount++;
                            if (hasMap && map) {
                                bundle[mapFilename].source = map.toString();
                            }
                            return {
                                key: file,
                                source: code
                            };
                        });
                    }
                    debug('js handle finish, total: %d, no-cached: %d', groupedEntries.js.length, noCachedCount);
                }
                if (Array.isArray(groupedEntries.css)) {
                    let noCachedCount = 0;
                    for (let i = 0; i < groupedEntries.css.length; i++) {
                        const [file, originalSource] = groupedEntries.css[i];
                        const rawSource = originalSource.source.toString();
                        const hash = cache.computeHash(rawSource);
                        cache.calcHashValueChanged(file, hash);
                        yield cache.process(file, () => {
                            const source = cache.get(file);
                            if (source) {
                                originalSource.source = source;
                                debug('css cache hit: %s', file);
                            }
                            else {
                                return false;
                            }
                        }, () => options.__awaiter(this, void 0, void 0, function* () {
                            const css = yield styleHandler(rawSource, {
                                isMainChunk: mainCssChunkMatcher(originalSource.fileName, appType)
                            });
                            originalSource.source = css;
                            onUpdate(file, rawSource, css);
                            debug('css handle: %s', file);
                            noCachedCount++;
                            return {
                                key: file,
                                source: css
                            };
                        }));
                    }
                    debug('css handle finish, total: %d, no-cached: %d', groupedEntries.css.length, noCachedCount);
                }
                onEnd();
                debug('end');
            });
        }
    };
}

exports.UnifiedViteWeappTailwindcssPlugin = UnifiedViteWeappTailwindcssPlugin;
