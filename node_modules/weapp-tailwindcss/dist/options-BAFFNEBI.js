'use strict';

var micromatch = require('micromatch');
var MagicString = require('magic-string');
var replace = require('./replace.js');
var regex = require('@weapp-core/regex');
var escape$1 = require('@weapp-core/escape');
var escape = require('@ast-core/escape');
var generate = require('@babel/generator');
var parser = require('@babel/parser');
var traverse = require('@babel/traverse');
var defu = require('./defu-JkbfvVKI.js');
var defaults = require('./defaults-qX2VLo8u.js');
var t = require('@babel/types');
var htmlparser2 = require('htmlparser2');
var postcss = require('postcss');
var plugin = require('./plugin-Bxt3oO75.js');
var postcssIsPseudoClass = require('@csstools/postcss-is-pseudo-class');
var path = require('node:path');
var fs = require('node:fs');
var semver = require('semver');
var tailwindcssPatch = require('tailwindcss-patch');
var shared = require('@tailwindcss-mangle/shared');
var lruCache = require('lru-cache');
var md5 = require('md5');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

function _interopNamespaceCompat(e) {
    if (e && typeof e === 'object' && 'default' in e) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var MagicString__default = /*#__PURE__*/_interopDefaultCompat(MagicString);
var generate__default = /*#__PURE__*/_interopDefaultCompat(generate);
var traverse__default = /*#__PURE__*/_interopDefaultCompat(traverse);
var t__namespace = /*#__PURE__*/_interopNamespaceCompat(t);
var postcss__default = /*#__PURE__*/_interopDefaultCompat(postcss);
var postcssIsPseudoClass__default = /*#__PURE__*/_interopDefaultCompat(postcssIsPseudoClass);
var path__default = /*#__PURE__*/_interopDefaultCompat(path);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var md5__default = /*#__PURE__*/_interopDefaultCompat(md5);

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const validateFilterRE = /[\w%-?\u00A0-\uFFFF-]/;
function isValidSelector(selector = '') {
    return validateFilterRE.test(selector);
}
const splitCode = (code, allowDoubleQuotes = false) => {
    const splitter = allowDoubleQuotes ? /\s+/ : /\s+|"/;
    return code.split(splitter).filter((element) => isValidSelector(element));
};

function regenerateHandleValue(str, node, options) {
    const { classNameSet: set, escapeMap, always, arbitraryValues, mangleContext: ctx, jsPreserveClass } = options;
    const allowDoubleQuotes = arbitraryValues === null || arbitraryValues === void 0 ? void 0 : arbitraryValues.allowDoubleQuotes;
    const arr = splitCode(str, allowDoubleQuotes);
    let rawStr = str;
    for (const v of arr) {
        if (always || (set && set.has(v) && !(jsPreserveClass === null || jsPreserveClass === void 0 ? void 0 : jsPreserveClass(v)))) {
            let ignoreFlag = false;
            if (Array.isArray(node.leadingComments)) {
                ignoreFlag = node.leadingComments.findIndex((x) => x.value.includes('weapp-tw') && x.value.includes('ignore')) > -1;
            }
            if (!ignoreFlag) {
                if (ctx) {
                    rawStr = ctx.jsHandler(rawStr);
                }
                rawStr = rawStr.replace(new RegExp(regex.escapeStringRegexp(v)), replace.replaceJs(v, {
                    escapeMap
                }));
            }
        }
    }
    return rawStr;
}
function replaceHandleValue(str, node, options, ms, offset = 0, needEscaped = false) {
    const { classNameSet: set, escapeMap, always, arbitraryValues, mangleContext: ctx, jsPreserveClass } = options;
    const allowDoubleQuotes = arbitraryValues === null || arbitraryValues === void 0 ? void 0 : arbitraryValues.allowDoubleQuotes;
    const arr = splitCode(str, allowDoubleQuotes);
    let rawStr = str;
    for (const v of arr) {
        if (always || (set && set.has(v) && !(jsPreserveClass === null || jsPreserveClass === void 0 ? void 0 : jsPreserveClass(v)))) {
            let ignoreFlag = false;
            if (Array.isArray(node.leadingComments)) {
                ignoreFlag = node.leadingComments.findIndex((x) => x.value.includes('weapp-tw') && x.value.includes('ignore')) > -1;
            }
            if (!ignoreFlag) {
                if (ctx) {
                    rawStr = ctx.jsHandler(rawStr);
                }
                rawStr = rawStr.replace(new RegExp(regex.escapeStringRegexp(v)), replace.replaceJs(v, {
                    escapeMap
                }));
            }
        }
    }
    if (typeof node.start === 'number' && typeof node.end === 'number') {
        const start = node.start + offset;
        const end = node.end - offset;
        if (start < end && str !== rawStr) {
            const content = needEscaped ? escape.jsStringEscape(rawStr) : rawStr;
            ms.update(start, end, content);
        }
    }
    return rawStr;
}

const isProd = () => process.env.NODE_ENV === 'production';

function isEvalPath(p) {
    if (p.isCallExpression()) {
        const calleePath = p.get('callee');
        return calleePath.isIdentifier() && calleePath.node.name === 'eval';
    }
    return false;
}
function jsHandler(rawSource, options) {
    var _a;
    let ast;
    try {
        ast = parser.parse(rawSource, {
            sourceType: 'unambiguous'
        });
    }
    catch (_b) {
        return {
            code: rawSource
        };
    }
    if (options.strategy === 'replace') {
        const ms = new MagicString__default["default"](rawSource);
        const ropt = {
            StringLiteral: {
                enter(p) {
                    var _a;
                    if (isEvalPath(p.parentPath)) {
                        return;
                    }
                    const n = p.node;
                    replaceHandleValue(n.value, n, options, ms, 1, (_a = options.needEscaped) !== null && _a !== void 0 ? _a : true);
                }
            },
            TemplateElement: {
                enter(p) {
                    if (p.parentPath.isTemplateLiteral() && isEvalPath(p.parentPath.parentPath)) {
                        return;
                    }
                    const n = p.node;
                    replaceHandleValue(n.value.raw, n, options, ms, 0, false);
                }
            },
            CallExpression: {
                enter(p) {
                    if (isEvalPath(p)) {
                        p.traverse({
                            StringLiteral: {
                                enter(s) {
                                    const res = jsHandler(s.node.value, Object.assign(Object.assign({}, options), { needEscaped: false, generateMap: false }));
                                    if (res.code) {
                                        const node = s.node;
                                        if (typeof node.start === 'number' && typeof node.end === 'number') {
                                            const start = node.start + 1;
                                            const end = node.end - 1;
                                            if (start < end && s.node.value !== res.code) {
                                                ms.update(start, end, escape.jsStringEscape(res.code));
                                                node.value = res.code;
                                            }
                                        }
                                    }
                                }
                            },
                            TemplateElement: {
                                enter(s) {
                                    const res = jsHandler(s.node.value.raw, Object.assign(Object.assign({}, options), { generateMap: false }));
                                    if (res.code) {
                                        const node = s.node;
                                        if (typeof node.start === 'number' && typeof node.end === 'number') {
                                            const start = node.start;
                                            const end = node.end;
                                            if (start < end && s.node.value.raw !== res.code) {
                                                ms.update(start, end, res.code);
                                                s.node.value.raw = res.code;
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
            }
        };
        traverse__default["default"](ast, ropt);
        const result = {
            code: ms.toString()
        };
        return result;
    }
    else {
        const gopt = {
            StringLiteral: {
                enter(p) {
                    if (isEvalPath(p.parentPath)) {
                        return;
                    }
                    const n = p.node;
                    n.value = regenerateHandleValue(n.value, n, options);
                }
            },
            TemplateElement: {
                enter(p) {
                    if (p.parentPath.isTemplateLiteral() && isEvalPath(p.parentPath.parentPath)) {
                        return;
                    }
                    const n = p.node;
                    n.value.raw = regenerateHandleValue(n.value.raw, n, options);
                }
            },
            CallExpression: {
                enter(p) {
                    if (isEvalPath(p)) {
                        p.traverse({
                            StringLiteral: {
                                enter(s) {
                                    const res = jsHandler(s.node.value, options);
                                    if (res.code) {
                                        s.node.value = res.code;
                                    }
                                }
                            },
                            TemplateElement: {
                                enter(s) {
                                    const res = jsHandler(s.node.value.raw, options);
                                    if (res.code) {
                                        s.node.value.raw = res.code;
                                    }
                                }
                            }
                        });
                    }
                }
            }
        };
        traverse__default["default"](ast, gopt);
        return generate__default["default"](ast, {
            minified: (_a = options.minifiedJs) !== null && _a !== void 0 ? _a : isProd()
        });
    }
}
function createJsHandler(options) {
    const { mangleContext, arbitraryValues, minifiedJs, escapeMap, jsPreserveClass, strategy, generateMap } = options;
    return (rawSource, set, options) => {
        const opts = defu.defu(options, {
            classNameSet: set,
            minifiedJs,
            escapeMap,
            arbitraryValues,
            mangleContext,
            jsPreserveClass,
            strategy,
            generateMap
        });
        return jsHandler(rawSource, opts);
    };
}

function generateCode(match, options = {}) {
    try {
        const ast = parser.parseExpression(match);
        const ms = new MagicString__default["default"](match);
        traverse__default["default"](ast, {
            StringLiteral(path) {
                var _a;
                if (t__namespace.isMemberExpression(path.parent)) {
                    return;
                }
                if (t__namespace.isBinaryExpression(path.parent) && t__namespace.isConditionalExpression((_a = path.parentPath) === null || _a === void 0 ? void 0 : _a.parent)) {
                    return;
                }
                const n = path.node;
                replaceHandleValue(n.value, n, {
                    always: true,
                    classNameSet: options.runtimeSet,
                    mangleContext: options.mangleContext,
                    escapeMap: options.escapeMap,
                    needEscaped: true
                }, ms, 1, true);
            },
            noScope: true
        });
        return ms.toString();
    }
    catch (_a) {
        return match;
    }
}
function extract(original, reg) {
    let match = reg.exec(original);
    const sources = [];
    while (match !== null) {
        const start = match.index;
        const end = reg.lastIndex;
        sources.push({
            start,
            end,
            raw: match[1]
        });
        match = reg.exec(original);
    }
    return sources;
}
function extractSource(original) {
    return extract(original, regex.variableRegExp);
}
function templateReplacer(original, options = {}) {
    const sources = extractSource(original);
    if (sources.length > 0) {
        const resultArray = [];
        let p = 0;
        for (let i = 0; i < sources.length; i++) {
            const m = sources[i];
            const before = original.slice(p, m.start);
            resultArray.push(replace.replaceJs(before, {
                keepEOL: true,
                escapeMap: options.escapeMap,
                mangleContext: options.mangleContext
            }));
            p = m.start;
            if (m.raw.trim().length > 0) {
                const code = generateCode(m.raw, options);
                const source = `{{${code}}}`;
                m.source = source;
            }
            else {
                m.source = '';
            }
            resultArray.push(m.source);
            p = m.end;
            if (i === sources.length - 1) {
                const after = original.slice(m.end);
                resultArray.push(replace.replaceJs(after, {
                    keepEOL: true,
                    escapeMap: options.escapeMap,
                    mangleContext: options.mangleContext
                }));
            }
        }
        return resultArray.filter(Boolean).join('').trim();
    }
    else {
        return replace.replaceJs(original, {
            keepEOL: false,
            escapeMap: options.escapeMap,
            mangleContext: options.mangleContext
        });
    }
}
function regTest(reg, str) {
    reg.lastIndex = 0;
    return reg.test(str);
}
function isPropsMatch(props, attr) {
    if (Array.isArray(props)) {
        for (const prop of props) {
            const res = typeof prop === 'string' ? prop.toLowerCase() === attr : regTest(prop, attr);
            if (res) {
                return res;
            }
        }
        return false;
    }
    else if (typeof props === 'string') {
        return props === attr;
    }
    else {
        return regTest(props, attr);
    }
}
function customTemplateHandler(rawSource, options) {
    const { customAttributesEntities = [], disabledDefaultTemplateHandler, inlineWxs, runtimeSet, jsHandler } = options !== null && options !== void 0 ? options : {};
    const s = new MagicString__default["default"](rawSource);
    let tag = '';
    const parser = new htmlparser2.Parser({
        onopentagname(name) {
            tag = name;
        },
        onattribute(name, value, quote) {
            if (value) {
                function update() {
                    s.update(parser.startIndex + name.length + 2, parser.endIndex - 1, templateReplacer(value, Object.assign(Object.assign({}, options), { quote })));
                }
                if (!disabledDefaultTemplateHandler && (name === 'class' || name === 'hover-class' || name === 'virtualhostclass')) {
                    update();
                }
                for (const [t, props] of customAttributesEntities) {
                    if (t === '*') {
                        if (isPropsMatch(props, name)) {
                            update();
                        }
                    }
                    else if (typeof t === 'string') {
                        if (t === tag && isPropsMatch(props, name)) {
                            update();
                        }
                    }
                    else if (regTest(t, tag) && isPropsMatch(props, name)) {
                        update();
                    }
                }
            }
        },
        ontext(data) {
            if (inlineWxs && tag === 'wxs') {
                const code = jsHandler(data, runtimeSet).code;
                s.update(parser.startIndex, parser.endIndex + 1, code);
            }
        },
        onclosetag() {
            tag = '';
        }
    });
    parser.write(s.original);
    parser.end();
    return s.toString();
}
function createTemplateHandler(options = {}) {
    return (rawSource, opt = {}) => {
        return customTemplateHandler(rawSource, defu.defu(opt, options));
    };
}

function styleHandler(rawSource, options) {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield postcss__default["default"]([postcssIsPseudoClass__default["default"](), plugin.postcssWeappTailwindcss(options)])
            .process(rawSource)
            .async()).css;
    });
}
function createStyleHandler(options) {
    return (rawSource, opt) => {
        return styleHandler(rawSource, defu.defu(opt, options));
    };
}

const createInjectPreflight = (options) => {
    const result = [];
    if (options && typeof options === 'object') {
        const entries = Object.entries(options);
        for (const [prop, value] of entries) {
            if (value !== false) {
                result.push({
                    prop,
                    value: value.toString()
                });
            }
        }
    }
    return () => {
        return result;
    };
};

function findAstNode(content, options) {
    const DOPTS = options.dangerousOptions;
    const ast = parser.parse(content);
    let arrayRef;
    let changed = false;
    traverse__default["default"](ast, {
        Identifier(path) {
            if (path.node.name === DOPTS.variableName && t__namespace.isVariableDeclarator(path.parent) && t__namespace.isArrayExpression(path.parent.init)) {
                arrayRef = path.parent.init;
                const set = new Set(path.parent.init.elements.map((x) => x.value));
                for (let i = 0; i < options.units.length; i++) {
                    const unit = options.units[i];
                    if (!set.has(unit)) {
                        path.parent.init.elements = path.parent.init.elements.map((x) => {
                            if (t__namespace.isStringLiteral(x)) {
                                return {
                                    type: x === null || x === void 0 ? void 0 : x.type,
                                    value: x === null || x === void 0 ? void 0 : x.value
                                };
                            }
                            return x;
                        });
                        path.parent.init.elements.push({
                            type: 'StringLiteral',
                            value: unit
                        });
                        changed = true;
                    }
                }
            }
        }
    });
    return {
        arrayRef,
        changed
    };
}

function getInstalledPkgJsonPath(options) {
    const dangerousOptions = options.dangerousOptions;
    try {
        const tmpJsonPath = tailwindcssPatch.requireResolve(`${dangerousOptions.packageName}/package.json`, {
            paths: options.paths,
            basedir: options.basedir
        });
        return tmpJsonPath;
    }
    catch (error) {
        if (error.code === 'MODULE_NOT_FOUND') {
            console.warn('没有找到`tailwindcss`包，请确认是否安装。想要禁用打上rpx支持patch或者非`tailwindcss`框架，你可以设置 `supportCustomLengthUnitsPatch` 为 false');
        }
    }
}
function createPatch(options) {
    if (options === false) {
        return defaults.noop;
    }
    return () => {
        try {
            return internalPatch(getInstalledPkgJsonPath(options), options);
        }
        catch (error) {
            console.warn(`patch tailwindcss failed:` + error.message);
        }
    };
}
function monkeyPatchForSupportingCustomUnit(rootDir, options) {
    var _a;
    const { dangerousOptions } = options;
    const DOPTS = dangerousOptions;
    const dataTypesFilePath = path__default["default"].resolve(rootDir, DOPTS.lengthUnitsFilePath);
    const dataTypesFileContent = fs__default["default"].readFileSync(dataTypesFilePath, {
        encoding: 'utf8'
    });
    const { arrayRef, changed } = findAstNode(dataTypesFileContent, options);
    if (arrayRef && changed) {
        const { code } = generate__default["default"](arrayRef, {
            jsescOption: {
                quotes: 'single'
            }
        });
        if (arrayRef.start && arrayRef.end) {
            const prev = dataTypesFileContent.slice(0, arrayRef.start);
            const next = dataTypesFileContent.slice(arrayRef.end);
            const newCode = prev + code + next;
            if (DOPTS.overwrite) {
                fs__default["default"].writeFileSync((_a = DOPTS.destPath) !== null && _a !== void 0 ? _a : dataTypesFilePath, newCode, {
                    encoding: 'utf8'
                });
                console.log('patch tailwindcss for custom length unit successfully!');
            }
        }
        return code;
    }
}
function internalPatch(pkgJsonPath, options, overwrite = true) {
    if (pkgJsonPath) {
        const pkgJson = require(pkgJsonPath);
        const dangerousOptions = options.dangerousOptions;
        const version = pkgJson.version;
        if (semver.gte(version, dangerousOptions.gteVersion)) {
            const rootDir = path__default["default"].dirname(pkgJsonPath);
            const dataTypes = monkeyPatchForSupportingCustomUnit(rootDir, options);
            const result = tailwindcssPatch.monkeyPatchForExposingContext(rootDir, {
                overwrite,
                version
            });
            return Object.assign(Object.assign({}, result), { dataTypes });
        }
    }
}
function createTailwindcssPatcher() {
    return new tailwindcssPatch.TailwindcssPatcher({
        cache: true
    });
}

function getSelf(x) {
    return x;
}
const defaultMangleContext = {
    rawOptions: false,
    runtimeSet: new Set(),
    classGenerator: new shared.ClassGenerator(),
    filter: shared.defaultMangleClassFilter,
    cssHandler: getSelf,
    jsHandler: getSelf,
    wxmlHandler: getSelf
};
function useMangleStore() {
    const ctx = Object.assign({}, defaultMangleContext);
    function resetMangle() {
        return Object.assign(ctx, defaultMangleContext);
    }
    function handleValue(rawSource) {
        const arr = splitCode(rawSource);
        for (const x of arr) {
            if (ctx.runtimeSet.has(x)) {
                rawSource = rawSource.replace(new RegExp(regex.escapeStringRegexp(x)), ctx.classGenerator.generateClassName(x).name);
            }
        }
        return rawSource;
    }
    function initMangle(options) {
        var _a;
        ctx.rawOptions = options;
        if (options) {
            if (options === true) {
                options = {
                    classGenerator: {},
                    mangleClassFilter: shared.defaultMangleClassFilter
                };
            }
            ctx.classGenerator = new shared.ClassGenerator(options.classGenerator);
            ctx.filter = (_a = options.mangleClassFilter) !== null && _a !== void 0 ? _a : shared.defaultMangleClassFilter;
            ctx.jsHandler = (rawSource) => {
                return handleValue(rawSource);
            };
            ctx.cssHandler = (rawSource) => {
                return handleValue(rawSource);
            };
            ctx.wxmlHandler = (rawSource) => {
                return handleValue(rawSource);
            };
        }
    }
    function setMangleRuntimeSet(runtimeSet) {
        const newSet = new Set();
        for (const c of runtimeSet) {
            if (ctx.filter(c)) {
                newSet.add(c);
            }
        }
        ctx.runtimeSet = newSet;
    }
    return {
        mangleContext: ctx,
        resetMangle,
        initMangle,
        setMangleRuntimeSet
    };
}

function createCache() {
    const hashMap = new Map();
    const instance = new lruCache.LRUCache({
        max: 1024,
        ttl: 0,
        ttlAutopurge: false
    });
    return {
        hashMap,
        instance,
        hasHashKey(key) {
            return hashMap.has(key);
        },
        getHashValue(key) {
            return hashMap.get(key);
        },
        setHashValue(key, value) {
            return hashMap.set(key, value);
        },
        get(key) {
            return instance.get(key);
        },
        set(key, value) {
            return instance.set(key, value);
        },
        computeHash(message) {
            return md5__default["default"](message);
        },
        calcHashValueChanged(key, hash) {
            const hit = this.getHashValue(key);
            if (hit) {
                this.setHashValue(key, {
                    changed: hash !== hit.hash,
                    hash
                });
            }
            else {
                this.setHashValue(key, {
                    changed: true,
                    hash
                });
            }
            return this;
        },
        has(key) {
            return instance.has(key);
        },
        process(key, callback, fallback) {
            return __awaiter(this, void 0, void 0, function* () {
                const hit = this.getHashValue(key);
                if (hit && !hit.changed) {
                    const returnFlag = yield callback();
                    if (returnFlag !== false) {
                        return;
                    }
                }
                const res = yield fallback();
                if (res) {
                    this.set(res.key, res.source);
                }
            });
        }
    };
}

function createGlobMatcher(pattern) {
    return function (file) {
        return micromatch.isMatch(file, pattern);
    };
}
function normalizeMatcher(options, key) {
    if (typeof options[key] === 'string' || Array.isArray(options[key])) {
        options[key] = createGlobMatcher(options[key]);
    }
}
function getOptions(options = {}) {
    if (options.supportCustomLengthUnitsPatch === true) {
        options.supportCustomLengthUnitsPatch = undefined;
    }
    if (options.customReplaceDictionary === undefined || options.customReplaceDictionary === 'simple') {
        options.customReplaceDictionary = escape$1.SimpleMappingChars2String;
    }
    else if (options.customReplaceDictionary === 'complex') {
        options.customReplaceDictionary = escape$1.MappingChars2String;
    }
    normalizeMatcher(options, 'cssMatcher');
    normalizeMatcher(options, 'htmlMatcher');
    normalizeMatcher(options, 'jsMatcher');
    normalizeMatcher(options, 'wxsMatcher');
    normalizeMatcher(options, 'mainCssChunkMatcher');
    const result = defu.defu(options, defaults.defaultOptions, {
        minifiedJs: isProd()
    });
    const { cssPreflight, customRuleCallback, cssPreflightRange, replaceUniversalSelectorWith, customAttributes, customReplaceDictionary, supportCustomLengthUnitsPatch, arbitraryValues, cssChildCombinatorReplaceValue, inlineWxs, injectAdditionalCssVarScope, jsPreserveClass, disabledDefaultTemplateHandler, jsEscapeStrategy, cssSelectorReplacement } = result;
    result.escapeMap = customReplaceDictionary;
    const cssInjectPreflight = createInjectPreflight(cssPreflight);
    const customAttributesEntities = defaults.isMap(options.customAttributes)
        ? [...options.customAttributes.entries()]
        : Object.entries(customAttributes);
    const { escapeMap, minifiedJs } = result;
    const { initMangle, mangleContext, setMangleRuntimeSet } = useMangleStore();
    initMangle(options.mangle);
    const styleHandler = createStyleHandler({
        cssInjectPreflight,
        customRuleCallback,
        cssPreflightRange,
        replaceUniversalSelectorWith,
        escapeMap,
        mangleContext,
        cssChildCombinatorReplaceValue,
        injectAdditionalCssVarScope,
        cssSelectorReplacement
    });
    result.styleHandler = styleHandler;
    const jsHandler = createJsHandler({
        minifiedJs,
        escapeMap,
        mangleContext,
        arbitraryValues,
        jsPreserveClass,
        strategy: jsEscapeStrategy,
        generateMap: true
    });
    result.jsHandler = jsHandler;
    const templateHandler = createTemplateHandler({
        customAttributesEntities,
        escapeMap,
        mangleContext,
        inlineWxs,
        jsHandler,
        disabledDefaultTemplateHandler
    });
    result.templateHandler = templateHandler;
    result.patch = createPatch(supportCustomLengthUnitsPatch);
    result.setMangleRuntimeSet = setMangleRuntimeSet;
    result.cache = createCache();
    return result;
}

exports.__awaiter = __awaiter;
exports.createPatch = createPatch;
exports.createTailwindcssPatcher = createTailwindcssPatcher;
exports.getOptions = getOptions;
