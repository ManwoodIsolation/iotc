import { isMatch } from 'micromatch';
import MagicString from 'magic-string';
import { replaceJs as replaceWxml } from './replace.mjs';
import { escapeStringRegexp, variableRegExp } from '@weapp-core/regex';
import { SimpleMappingChars2String, MappingChars2String } from '@weapp-core/escape';
import { jsStringEscape } from '@ast-core/escape';
import generate from '@babel/generator';
import { parse, parseExpression } from '@babel/parser';
import traverse from '@babel/traverse';
import { d as defu } from './defu-D2_bzAv0.mjs';
import { n as noop, d as defaultOptions, i as isMap } from './defaults-DMBtD8TO.mjs';
import * as t from '@babel/types';
import { Parser } from 'htmlparser2';
import postcss from 'postcss';
import { p as postcssWeappTailwindcss } from './plugin-Du3zrk3S.mjs';
import postcssIsPseudoClass from '@csstools/postcss-is-pseudo-class';
import path from 'node:path';
import fs from 'node:fs';
import { gte } from 'semver';
import { monkeyPatchForExposingContext, requireResolve, TailwindcssPatcher } from 'tailwindcss-patch';
import { ClassGenerator, defaultMangleClassFilter } from '@tailwindcss-mangle/shared';
import { LRUCache } from 'lru-cache';
import md5 from 'md5';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const validateFilterRE = /[\w%-?\u00A0-\uFFFF-]/;
function isValidSelector(selector = '') {
    return validateFilterRE.test(selector);
}
const splitCode = (code, allowDoubleQuotes = false) => {
    const splitter = allowDoubleQuotes ? /\s+/ : /\s+|"/;
    return code.split(splitter).filter((element) => isValidSelector(element));
};

function regenerateHandleValue(str, node, options) {
    const { classNameSet: set, escapeMap, always, arbitraryValues, mangleContext: ctx, jsPreserveClass } = options;
    const allowDoubleQuotes = arbitraryValues === null || arbitraryValues === void 0 ? void 0 : arbitraryValues.allowDoubleQuotes;
    const arr = splitCode(str, allowDoubleQuotes);
    let rawStr = str;
    for (const v of arr) {
        if (always || (set && set.has(v) && !(jsPreserveClass === null || jsPreserveClass === void 0 ? void 0 : jsPreserveClass(v)))) {
            let ignoreFlag = false;
            if (Array.isArray(node.leadingComments)) {
                ignoreFlag = node.leadingComments.findIndex((x) => x.value.includes('weapp-tw') && x.value.includes('ignore')) > -1;
            }
            if (!ignoreFlag) {
                if (ctx) {
                    rawStr = ctx.jsHandler(rawStr);
                }
                rawStr = rawStr.replace(new RegExp(escapeStringRegexp(v)), replaceWxml(v, {
                    escapeMap
                }));
            }
        }
    }
    return rawStr;
}
function replaceHandleValue(str, node, options, ms, offset = 0, needEscaped = false) {
    const { classNameSet: set, escapeMap, always, arbitraryValues, mangleContext: ctx, jsPreserveClass } = options;
    const allowDoubleQuotes = arbitraryValues === null || arbitraryValues === void 0 ? void 0 : arbitraryValues.allowDoubleQuotes;
    const arr = splitCode(str, allowDoubleQuotes);
    let rawStr = str;
    for (const v of arr) {
        if (always || (set && set.has(v) && !(jsPreserveClass === null || jsPreserveClass === void 0 ? void 0 : jsPreserveClass(v)))) {
            let ignoreFlag = false;
            if (Array.isArray(node.leadingComments)) {
                ignoreFlag = node.leadingComments.findIndex((x) => x.value.includes('weapp-tw') && x.value.includes('ignore')) > -1;
            }
            if (!ignoreFlag) {
                if (ctx) {
                    rawStr = ctx.jsHandler(rawStr);
                }
                rawStr = rawStr.replace(new RegExp(escapeStringRegexp(v)), replaceWxml(v, {
                    escapeMap
                }));
            }
        }
    }
    if (typeof node.start === 'number' && typeof node.end === 'number') {
        const start = node.start + offset;
        const end = node.end - offset;
        if (start < end && str !== rawStr) {
            const content = needEscaped ? jsStringEscape(rawStr) : rawStr;
            ms.update(start, end, content);
        }
    }
    return rawStr;
}

const isProd = () => process.env.NODE_ENV === 'production';

function isEvalPath(p) {
    if (p.isCallExpression()) {
        const calleePath = p.get('callee');
        return calleePath.isIdentifier() && calleePath.node.name === 'eval';
    }
    return false;
}
function jsHandler(rawSource, options) {
    var _a;
    let ast;
    try {
        ast = parse(rawSource, {
            sourceType: 'unambiguous'
        });
    }
    catch (_b) {
        return {
            code: rawSource
        };
    }
    if (options.strategy === 'replace') {
        const ms = new MagicString(rawSource);
        const ropt = {
            StringLiteral: {
                enter(p) {
                    var _a;
                    if (isEvalPath(p.parentPath)) {
                        return;
                    }
                    const n = p.node;
                    replaceHandleValue(n.value, n, options, ms, 1, (_a = options.needEscaped) !== null && _a !== void 0 ? _a : true);
                }
            },
            TemplateElement: {
                enter(p) {
                    if (p.parentPath.isTemplateLiteral() && isEvalPath(p.parentPath.parentPath)) {
                        return;
                    }
                    const n = p.node;
                    replaceHandleValue(n.value.raw, n, options, ms, 0, false);
                }
            },
            CallExpression: {
                enter(p) {
                    if (isEvalPath(p)) {
                        p.traverse({
                            StringLiteral: {
                                enter(s) {
                                    const res = jsHandler(s.node.value, Object.assign(Object.assign({}, options), { needEscaped: false, generateMap: false }));
                                    if (res.code) {
                                        const node = s.node;
                                        if (typeof node.start === 'number' && typeof node.end === 'number') {
                                            const start = node.start + 1;
                                            const end = node.end - 1;
                                            if (start < end && s.node.value !== res.code) {
                                                ms.update(start, end, jsStringEscape(res.code));
                                                node.value = res.code;
                                            }
                                        }
                                    }
                                }
                            },
                            TemplateElement: {
                                enter(s) {
                                    const res = jsHandler(s.node.value.raw, Object.assign(Object.assign({}, options), { generateMap: false }));
                                    if (res.code) {
                                        const node = s.node;
                                        if (typeof node.start === 'number' && typeof node.end === 'number') {
                                            const start = node.start;
                                            const end = node.end;
                                            if (start < end && s.node.value.raw !== res.code) {
                                                ms.update(start, end, res.code);
                                                s.node.value.raw = res.code;
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
            }
        };
        traverse(ast, ropt);
        const result = {
            code: ms.toString()
        };
        return result;
    }
    else {
        const gopt = {
            StringLiteral: {
                enter(p) {
                    if (isEvalPath(p.parentPath)) {
                        return;
                    }
                    const n = p.node;
                    n.value = regenerateHandleValue(n.value, n, options);
                }
            },
            TemplateElement: {
                enter(p) {
                    if (p.parentPath.isTemplateLiteral() && isEvalPath(p.parentPath.parentPath)) {
                        return;
                    }
                    const n = p.node;
                    n.value.raw = regenerateHandleValue(n.value.raw, n, options);
                }
            },
            CallExpression: {
                enter(p) {
                    if (isEvalPath(p)) {
                        p.traverse({
                            StringLiteral: {
                                enter(s) {
                                    const res = jsHandler(s.node.value, options);
                                    if (res.code) {
                                        s.node.value = res.code;
                                    }
                                }
                            },
                            TemplateElement: {
                                enter(s) {
                                    const res = jsHandler(s.node.value.raw, options);
                                    if (res.code) {
                                        s.node.value.raw = res.code;
                                    }
                                }
                            }
                        });
                    }
                }
            }
        };
        traverse(ast, gopt);
        return generate(ast, {
            minified: (_a = options.minifiedJs) !== null && _a !== void 0 ? _a : isProd()
        });
    }
}
function createJsHandler(options) {
    const { mangleContext, arbitraryValues, minifiedJs, escapeMap, jsPreserveClass, strategy, generateMap } = options;
    return (rawSource, set, options) => {
        const opts = defu(options, {
            classNameSet: set,
            minifiedJs,
            escapeMap,
            arbitraryValues,
            mangleContext,
            jsPreserveClass,
            strategy,
            generateMap
        });
        return jsHandler(rawSource, opts);
    };
}

function generateCode(match, options = {}) {
    try {
        const ast = parseExpression(match);
        const ms = new MagicString(match);
        traverse(ast, {
            StringLiteral(path) {
                var _a;
                if (t.isMemberExpression(path.parent)) {
                    return;
                }
                if (t.isBinaryExpression(path.parent) && t.isConditionalExpression((_a = path.parentPath) === null || _a === void 0 ? void 0 : _a.parent)) {
                    return;
                }
                const n = path.node;
                replaceHandleValue(n.value, n, {
                    always: true,
                    classNameSet: options.runtimeSet,
                    mangleContext: options.mangleContext,
                    escapeMap: options.escapeMap,
                    needEscaped: true
                }, ms, 1, true);
            },
            noScope: true
        });
        return ms.toString();
    }
    catch (_a) {
        return match;
    }
}
function extract(original, reg) {
    let match = reg.exec(original);
    const sources = [];
    while (match !== null) {
        const start = match.index;
        const end = reg.lastIndex;
        sources.push({
            start,
            end,
            raw: match[1]
        });
        match = reg.exec(original);
    }
    return sources;
}
function extractSource(original) {
    return extract(original, variableRegExp);
}
function templateReplacer(original, options = {}) {
    const sources = extractSource(original);
    if (sources.length > 0) {
        const resultArray = [];
        let p = 0;
        for (let i = 0; i < sources.length; i++) {
            const m = sources[i];
            const before = original.slice(p, m.start);
            resultArray.push(replaceWxml(before, {
                keepEOL: true,
                escapeMap: options.escapeMap,
                mangleContext: options.mangleContext
            }));
            p = m.start;
            if (m.raw.trim().length > 0) {
                const code = generateCode(m.raw, options);
                const source = `{{${code}}}`;
                m.source = source;
            }
            else {
                m.source = '';
            }
            resultArray.push(m.source);
            p = m.end;
            if (i === sources.length - 1) {
                const after = original.slice(m.end);
                resultArray.push(replaceWxml(after, {
                    keepEOL: true,
                    escapeMap: options.escapeMap,
                    mangleContext: options.mangleContext
                }));
            }
        }
        return resultArray.filter(Boolean).join('').trim();
    }
    else {
        return replaceWxml(original, {
            keepEOL: false,
            escapeMap: options.escapeMap,
            mangleContext: options.mangleContext
        });
    }
}
function regTest(reg, str) {
    reg.lastIndex = 0;
    return reg.test(str);
}
function isPropsMatch(props, attr) {
    if (Array.isArray(props)) {
        for (const prop of props) {
            const res = typeof prop === 'string' ? prop.toLowerCase() === attr : regTest(prop, attr);
            if (res) {
                return res;
            }
        }
        return false;
    }
    else if (typeof props === 'string') {
        return props === attr;
    }
    else {
        return regTest(props, attr);
    }
}
function customTemplateHandler(rawSource, options) {
    const { customAttributesEntities = [], disabledDefaultTemplateHandler, inlineWxs, runtimeSet, jsHandler } = options !== null && options !== void 0 ? options : {};
    const s = new MagicString(rawSource);
    let tag = '';
    const parser = new Parser({
        onopentagname(name) {
            tag = name;
        },
        onattribute(name, value, quote) {
            if (value) {
                function update() {
                    s.update(parser.startIndex + name.length + 2, parser.endIndex - 1, templateReplacer(value, Object.assign(Object.assign({}, options), { quote })));
                }
                if (!disabledDefaultTemplateHandler && (name === 'class' || name === 'hover-class' || name === 'virtualhostclass')) {
                    update();
                }
                for (const [t, props] of customAttributesEntities) {
                    if (t === '*') {
                        if (isPropsMatch(props, name)) {
                            update();
                        }
                    }
                    else if (typeof t === 'string') {
                        if (t === tag && isPropsMatch(props, name)) {
                            update();
                        }
                    }
                    else if (regTest(t, tag) && isPropsMatch(props, name)) {
                        update();
                    }
                }
            }
        },
        ontext(data) {
            if (inlineWxs && tag === 'wxs') {
                const code = jsHandler(data, runtimeSet).code;
                s.update(parser.startIndex, parser.endIndex + 1, code);
            }
        },
        onclosetag() {
            tag = '';
        }
    });
    parser.write(s.original);
    parser.end();
    return s.toString();
}
function createTemplateHandler(options = {}) {
    return (rawSource, opt = {}) => {
        return customTemplateHandler(rawSource, defu(opt, options));
    };
}

function styleHandler(rawSource, options) {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield postcss([postcssIsPseudoClass(), postcssWeappTailwindcss(options)])
            .process(rawSource)
            .async()).css;
    });
}
function createStyleHandler(options) {
    return (rawSource, opt) => {
        return styleHandler(rawSource, defu(opt, options));
    };
}

const createInjectPreflight = (options) => {
    const result = [];
    if (options && typeof options === 'object') {
        const entries = Object.entries(options);
        for (const [prop, value] of entries) {
            if (value !== false) {
                result.push({
                    prop,
                    value: value.toString()
                });
            }
        }
    }
    return () => {
        return result;
    };
};

function findAstNode(content, options) {
    const DOPTS = options.dangerousOptions;
    const ast = parse(content);
    let arrayRef;
    let changed = false;
    traverse(ast, {
        Identifier(path) {
            if (path.node.name === DOPTS.variableName && t.isVariableDeclarator(path.parent) && t.isArrayExpression(path.parent.init)) {
                arrayRef = path.parent.init;
                const set = new Set(path.parent.init.elements.map((x) => x.value));
                for (let i = 0; i < options.units.length; i++) {
                    const unit = options.units[i];
                    if (!set.has(unit)) {
                        path.parent.init.elements = path.parent.init.elements.map((x) => {
                            if (t.isStringLiteral(x)) {
                                return {
                                    type: x === null || x === void 0 ? void 0 : x.type,
                                    value: x === null || x === void 0 ? void 0 : x.value
                                };
                            }
                            return x;
                        });
                        path.parent.init.elements.push({
                            type: 'StringLiteral',
                            value: unit
                        });
                        changed = true;
                    }
                }
            }
        }
    });
    return {
        arrayRef,
        changed
    };
}

function getInstalledPkgJsonPath(options) {
    const dangerousOptions = options.dangerousOptions;
    try {
        const tmpJsonPath = requireResolve(`${dangerousOptions.packageName}/package.json`, {
            paths: options.paths,
            basedir: options.basedir
        });
        return tmpJsonPath;
    }
    catch (error) {
        if (error.code === 'MODULE_NOT_FOUND') {
            console.warn('没有找到`tailwindcss`包，请确认是否安装。想要禁用打上rpx支持patch或者非`tailwindcss`框架，你可以设置 `supportCustomLengthUnitsPatch` 为 false');
        }
    }
}
function createPatch(options) {
    if (options === false) {
        return noop;
    }
    return () => {
        try {
            return internalPatch(getInstalledPkgJsonPath(options), options);
        }
        catch (error) {
            console.warn(`patch tailwindcss failed:` + error.message);
        }
    };
}
function monkeyPatchForSupportingCustomUnit(rootDir, options) {
    var _a;
    const { dangerousOptions } = options;
    const DOPTS = dangerousOptions;
    const dataTypesFilePath = path.resolve(rootDir, DOPTS.lengthUnitsFilePath);
    const dataTypesFileContent = fs.readFileSync(dataTypesFilePath, {
        encoding: 'utf8'
    });
    const { arrayRef, changed } = findAstNode(dataTypesFileContent, options);
    if (arrayRef && changed) {
        const { code } = generate(arrayRef, {
            jsescOption: {
                quotes: 'single'
            }
        });
        if (arrayRef.start && arrayRef.end) {
            const prev = dataTypesFileContent.slice(0, arrayRef.start);
            const next = dataTypesFileContent.slice(arrayRef.end);
            const newCode = prev + code + next;
            if (DOPTS.overwrite) {
                fs.writeFileSync((_a = DOPTS.destPath) !== null && _a !== void 0 ? _a : dataTypesFilePath, newCode, {
                    encoding: 'utf8'
                });
                console.log('patch tailwindcss for custom length unit successfully!');
            }
        }
        return code;
    }
}
function internalPatch(pkgJsonPath, options, overwrite = true) {
    if (pkgJsonPath) {
        const pkgJson = require(pkgJsonPath);
        const dangerousOptions = options.dangerousOptions;
        const version = pkgJson.version;
        if (gte(version, dangerousOptions.gteVersion)) {
            const rootDir = path.dirname(pkgJsonPath);
            const dataTypes = monkeyPatchForSupportingCustomUnit(rootDir, options);
            const result = monkeyPatchForExposingContext(rootDir, {
                overwrite,
                version
            });
            return Object.assign(Object.assign({}, result), { dataTypes });
        }
    }
}
function createTailwindcssPatcher() {
    return new TailwindcssPatcher({
        cache: true
    });
}

function getSelf(x) {
    return x;
}
const defaultMangleContext = {
    rawOptions: false,
    runtimeSet: new Set(),
    classGenerator: new ClassGenerator(),
    filter: defaultMangleClassFilter,
    cssHandler: getSelf,
    jsHandler: getSelf,
    wxmlHandler: getSelf
};
function useMangleStore() {
    const ctx = Object.assign({}, defaultMangleContext);
    function resetMangle() {
        return Object.assign(ctx, defaultMangleContext);
    }
    function handleValue(rawSource) {
        const arr = splitCode(rawSource);
        for (const x of arr) {
            if (ctx.runtimeSet.has(x)) {
                rawSource = rawSource.replace(new RegExp(escapeStringRegexp(x)), ctx.classGenerator.generateClassName(x).name);
            }
        }
        return rawSource;
    }
    function initMangle(options) {
        var _a;
        ctx.rawOptions = options;
        if (options) {
            if (options === true) {
                options = {
                    classGenerator: {},
                    mangleClassFilter: defaultMangleClassFilter
                };
            }
            ctx.classGenerator = new ClassGenerator(options.classGenerator);
            ctx.filter = (_a = options.mangleClassFilter) !== null && _a !== void 0 ? _a : defaultMangleClassFilter;
            ctx.jsHandler = (rawSource) => {
                return handleValue(rawSource);
            };
            ctx.cssHandler = (rawSource) => {
                return handleValue(rawSource);
            };
            ctx.wxmlHandler = (rawSource) => {
                return handleValue(rawSource);
            };
        }
    }
    function setMangleRuntimeSet(runtimeSet) {
        const newSet = new Set();
        for (const c of runtimeSet) {
            if (ctx.filter(c)) {
                newSet.add(c);
            }
        }
        ctx.runtimeSet = newSet;
    }
    return {
        mangleContext: ctx,
        resetMangle,
        initMangle,
        setMangleRuntimeSet
    };
}

function createCache() {
    const hashMap = new Map();
    const instance = new LRUCache({
        max: 1024,
        ttl: 0,
        ttlAutopurge: false
    });
    return {
        hashMap,
        instance,
        hasHashKey(key) {
            return hashMap.has(key);
        },
        getHashValue(key) {
            return hashMap.get(key);
        },
        setHashValue(key, value) {
            return hashMap.set(key, value);
        },
        get(key) {
            return instance.get(key);
        },
        set(key, value) {
            return instance.set(key, value);
        },
        computeHash(message) {
            return md5(message);
        },
        calcHashValueChanged(key, hash) {
            const hit = this.getHashValue(key);
            if (hit) {
                this.setHashValue(key, {
                    changed: hash !== hit.hash,
                    hash
                });
            }
            else {
                this.setHashValue(key, {
                    changed: true,
                    hash
                });
            }
            return this;
        },
        has(key) {
            return instance.has(key);
        },
        process(key, callback, fallback) {
            return __awaiter(this, void 0, void 0, function* () {
                const hit = this.getHashValue(key);
                if (hit && !hit.changed) {
                    const returnFlag = yield callback();
                    if (returnFlag !== false) {
                        return;
                    }
                }
                const res = yield fallback();
                if (res) {
                    this.set(res.key, res.source);
                }
            });
        }
    };
}

function createGlobMatcher(pattern) {
    return function (file) {
        return isMatch(file, pattern);
    };
}
function normalizeMatcher(options, key) {
    if (typeof options[key] === 'string' || Array.isArray(options[key])) {
        options[key] = createGlobMatcher(options[key]);
    }
}
function getOptions(options = {}) {
    if (options.supportCustomLengthUnitsPatch === true) {
        options.supportCustomLengthUnitsPatch = undefined;
    }
    if (options.customReplaceDictionary === undefined || options.customReplaceDictionary === 'simple') {
        options.customReplaceDictionary = SimpleMappingChars2String;
    }
    else if (options.customReplaceDictionary === 'complex') {
        options.customReplaceDictionary = MappingChars2String;
    }
    normalizeMatcher(options, 'cssMatcher');
    normalizeMatcher(options, 'htmlMatcher');
    normalizeMatcher(options, 'jsMatcher');
    normalizeMatcher(options, 'wxsMatcher');
    normalizeMatcher(options, 'mainCssChunkMatcher');
    const result = defu(options, defaultOptions, {
        minifiedJs: isProd()
    });
    const { cssPreflight, customRuleCallback, cssPreflightRange, replaceUniversalSelectorWith, customAttributes, customReplaceDictionary, supportCustomLengthUnitsPatch, arbitraryValues, cssChildCombinatorReplaceValue, inlineWxs, injectAdditionalCssVarScope, jsPreserveClass, disabledDefaultTemplateHandler, jsEscapeStrategy, cssSelectorReplacement } = result;
    result.escapeMap = customReplaceDictionary;
    const cssInjectPreflight = createInjectPreflight(cssPreflight);
    const customAttributesEntities = isMap(options.customAttributes)
        ? [...options.customAttributes.entries()]
        : Object.entries(customAttributes);
    const { escapeMap, minifiedJs } = result;
    const { initMangle, mangleContext, setMangleRuntimeSet } = useMangleStore();
    initMangle(options.mangle);
    const styleHandler = createStyleHandler({
        cssInjectPreflight,
        customRuleCallback,
        cssPreflightRange,
        replaceUniversalSelectorWith,
        escapeMap,
        mangleContext,
        cssChildCombinatorReplaceValue,
        injectAdditionalCssVarScope,
        cssSelectorReplacement
    });
    result.styleHandler = styleHandler;
    const jsHandler = createJsHandler({
        minifiedJs,
        escapeMap,
        mangleContext,
        arbitraryValues,
        jsPreserveClass,
        strategy: jsEscapeStrategy,
        generateMap: true
    });
    result.jsHandler = jsHandler;
    const templateHandler = createTemplateHandler({
        customAttributesEntities,
        escapeMap,
        mangleContext,
        inlineWxs,
        jsHandler,
        disabledDefaultTemplateHandler
    });
    result.templateHandler = templateHandler;
    result.patch = createPatch(supportCustomLengthUnitsPatch);
    result.setMangleRuntimeSet = setMangleRuntimeSet;
    result.cache = createCache();
    return result;
}

export { __awaiter as _, createPatch as a, createTailwindcssPatcher as c, getOptions as g };
