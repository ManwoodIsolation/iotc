import selectorParser from 'postcss-selector-parser';
import { i as internalCssSelectorReplacer } from './shared-D4ZM_mI-.mjs';
import { Declaration, Rule } from 'postcss';
import '@csstools/postcss-is-pseudo-class';

const createTransform = (rule, options) => {
    const { replaceUniversalSelectorWith, escapeMap, mangleContext, cssSelectorReplacement } = options;
    const replaceFlag = replaceUniversalSelectorWith !== false;
    const transform = (selectors) => {
        selectors.walk((selector) => {
            if (selector.type === 'universal') {
                if (replaceFlag) {
                    selector.value = replaceUniversalSelectorWith;
                }
                else if (cssSelectorReplacement && cssSelectorReplacement.universal) {
                    selector.value = cssSelectorReplacement.universal;
                }
            }
            if (selector.type === 'selector') {
                const node = selector.nodes.find((x) => x.type === 'pseudo' && x.value === ':hover');
                node && selector.remove();
            }
            if (selector.type === 'pseudo' && selector.value === ':root' && cssSelectorReplacement && cssSelectorReplacement.root) {
                selector.value = cssSelectorReplacement.root;
            }
            if (selector.type === 'class') {
                selector.value = internalCssSelectorReplacer(selector.value, {
                    escapeMap,
                    mangleContext
                });
            }
        });
        if (selectors.length === 0) {
            rule.remove();
        }
    };
    return transform;
};
const getTransformer = (rule, options) => {
    return selectorParser(createTransform(rule, options));
};
const transformSync = (rule, options) => {
    const transformer = getTransformer(rule, options);
    return transformer.transformSync(rule, {
        lossless: false,
        updateSelector: true
    });
};

var cssVars = [
    {
        prop: '--tw-border-spacing-x',
        value: '0'
    },
    {
        prop: '--tw-border-spacing-y',
        value: '0'
    },
    {
        prop: '--tw-translate-x',
        value: '0'
    },
    {
        prop: '--tw-translate-y',
        value: '0'
    },
    {
        prop: '--tw-rotate',
        value: '0'
    },
    {
        prop: '--tw-skew-x',
        value: '0'
    },
    {
        prop: '--tw-skew-y',
        value: '0'
    },
    {
        prop: '--tw-scale-x',
        value: '1'
    },
    {
        prop: '--tw-scale-y',
        value: '1'
    },
    {
        prop: '--tw-pan-x',
        value: ' '
    },
    {
        prop: '--tw-pan-y',
        value: ' '
    },
    {
        prop: '--tw-pinch-zoom',
        value: ' '
    },
    {
        prop: '--tw-scroll-snap-strictness',
        value: 'proximity'
    },
    {
        prop: '--tw-gradient-from-position',
        value: ' '
    },
    {
        prop: '--tw-gradient-via-position',
        value: ' '
    },
    {
        prop: '--tw-gradient-to-position',
        value: ' '
    },
    {
        prop: '--tw-ordinal',
        value: ' '
    },
    {
        prop: '--tw-slashed-zero',
        value: ' '
    },
    {
        prop: '--tw-numeric-figure',
        value: ' '
    },
    {
        prop: '--tw-numeric-spacing',
        value: ' '
    },
    {
        prop: '--tw-numeric-fraction',
        value: ' '
    },
    {
        prop: '--tw-ring-inset',
        value: ' '
    },
    {
        prop: '--tw-ring-offset-width',
        value: '0px'
    },
    {
        prop: '--tw-ring-offset-color',
        value: '#fff'
    },
    {
        prop: '--tw-ring-color',
        value: 'rgb(59 130 246 / 0.5)'
    },
    {
        prop: '--tw-ring-offset-shadow',
        value: '0 0 #0000'
    },
    {
        prop: '--tw-ring-shadow',
        value: '0 0 #0000'
    },
    {
        prop: '--tw-shadow',
        value: '0 0 #0000'
    },
    {
        prop: '--tw-shadow-colored',
        value: '0 0 #0000'
    },
    {
        prop: '--tw-blur',
        value: ' '
    },
    {
        prop: '--tw-brightness',
        value: ' '
    },
    {
        prop: '--tw-contrast',
        value: ' '
    },
    {
        prop: '--tw-grayscale',
        value: ' '
    },
    {
        prop: '--tw-hue-rotate',
        value: ' '
    },
    {
        prop: '--tw-invert',
        value: ' '
    },
    {
        prop: '--tw-saturate',
        value: ' '
    },
    {
        prop: '--tw-sepia',
        value: ' '
    },
    {
        prop: '--tw-drop-shadow',
        value: ' '
    },
    {
        prop: '--tw-backdrop-blur',
        value: ' '
    },
    {
        prop: '--tw-backdrop-brightness',
        value: ' '
    },
    {
        prop: '--tw-backdrop-contrast',
        value: ' '
    },
    {
        prop: '--tw-backdrop-grayscale',
        value: ' '
    },
    {
        prop: '--tw-backdrop-hue-rotate',
        value: ' '
    },
    {
        prop: '--tw-backdrop-invert',
        value: ' '
    },
    {
        prop: '--tw-backdrop-opacity',
        value: ' '
    },
    {
        prop: '--tw-backdrop-saturate',
        value: ' '
    },
    {
        prop: '--tw-backdrop-sepia',
        value: ' '
    }
];

const initialNodes = cssVars.map((x) => {
    return new Declaration({
        prop: x.prop,
        value: x.value
    });
});
const PATTERNS = [/:not\(template\)\s*~\s*:not\(template\)/.source, /:not\(\[hidden\]\)\s*~\s*:not\(\[hidden\]\)/.source].join('|');
const BROAD_MATCH_GLOBAL_REGEXP = new RegExp(PATTERNS, 'g');
function testIfVariablesScope(node, count = 1) {
    if (/:?:before/.test(node.selector) && /:?:after/.test(node.selector)) {
        for (let i = 0; i < count; i++) {
            const tryTestDecl = node.nodes[i];
            if (tryTestDecl && tryTestDecl.type === 'decl' && tryTestDecl.prop.startsWith('--tw-')) {
                continue;
            }
            else {
                return false;
            }
        }
        return true;
    }
    return false;
}
function testIfTwBackdrop(node, count = 1) {
    if (node.type === 'rule' && node.selector === '::backdrop') {
        for (let i = 0; i < count; i++) {
            const tryTestDecl = node.nodes[i];
            if (tryTestDecl && tryTestDecl.type === 'decl' && tryTestDecl.prop.startsWith('--tw-')) {
                continue;
            }
            else {
                return false;
            }
        }
        return true;
    }
    return false;
}
function makePseudoVarRule() {
    const pseudoVarRule = new Rule({
        selector: '::before,::after'
    });
    pseudoVarRule.append(new Declaration({
        prop: '--tw-content',
        value: '""'
    }));
    return pseudoVarRule;
}
function remakeCssVarSelector(selectors, cssPreflightRange) {
    const idx = selectors.indexOf('*');
    if (idx > -1) {
        selectors.splice(idx, 1);
    }
    if (!selectors.includes('view')) {
        selectors.push('view');
    }
    if (cssPreflightRange === 'all' &&
        !selectors.includes(':not(not)')) {
        selectors.push(':not(not)');
    }
    return selectors;
}
function remakeCombinatorSelector(selector, cssChildCombinatorReplaceValue) {
    let childCombinatorReplaceValue = 'view + view';
    if (Array.isArray(cssChildCombinatorReplaceValue)) {
        childCombinatorReplaceValue = cssChildCombinatorReplaceValue
            .map((x) => {
            return x + ' + ' + x;
        })
            .join(',');
    }
    else if (typeof cssChildCombinatorReplaceValue === 'string') {
        childCombinatorReplaceValue = cssChildCombinatorReplaceValue;
    }
    return selector.replaceAll(BROAD_MATCH_GLOBAL_REGEXP, childCombinatorReplaceValue);
}
function commonChunkPreflight(node, options) {
    node.selector = remakeCombinatorSelector(node.selector, options.cssChildCombinatorReplaceValue);
    if (testIfVariablesScope(node)) {
        node.selectors = remakeCssVarSelector(node.selectors, options.cssPreflightRange);
        node.before(makePseudoVarRule());
        if (typeof options.cssInjectPreflight === 'function') {
            node.append(...options.cssInjectPreflight());
        }
    }
    if (options.injectAdditionalCssVarScope && testIfTwBackdrop(node)) {
        const syntheticRule = new Rule({
            selectors: ['::after', '::before'],
            nodes: initialNodes
        });
        syntheticRule.selectors = remakeCssVarSelector(syntheticRule.selectors, options.cssPreflightRange);
        node.before(syntheticRule);
        node.before(makePseudoVarRule());
        if (typeof options.cssInjectPreflight === 'function') {
            syntheticRule.append(...options.cssInjectPreflight());
        }
    }
}

const postcssPlugin = 'postcss-weapp-tailwindcss-rename-plugin';
const pluginName = 'weapp-tailwindcss-webpack-plugin';
const vitePluginName = 'vite-plugin-uni-app-weapp-tailwindcss-adaptor';

const postcssWeappTailwindcss = (options = {
    isMainChunk: true
}) => {
    const { customRuleCallback, isMainChunk } = options;
    const isCustomRuleCallbackFn = typeof customRuleCallback === 'function';
    return {
        postcssPlugin,
        Once(css) {
            css.walkRules((rule) => {
                transformSync(rule, options);
                isMainChunk && commonChunkPreflight(rule, options);
                isCustomRuleCallbackFn && customRuleCallback(rule, options);
            });
        },
        AtRule(atRule) {
            if (atRule.name === 'media' && /\(hover:\s*hover\)/.test(atRule.params)) {
                atRule.before(atRule.nodes);
                atRule.remove();
            }
        }
    };
};
postcssWeappTailwindcss.postcss = true;

export { pluginName as a, postcssWeappTailwindcss as p, vitePluginName as v };
